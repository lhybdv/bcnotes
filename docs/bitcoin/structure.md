# 比特币数据结构

## 1. 区块存储

1.  `blocks/blk*.dat` 的文件中存储了实际的块数据，这些数据以网络格式存储。它们仅用于重新扫描钱包中丢失的交易，将这些交易重新组织到链的不同部分，并将数据块提供给其他正在同步数据的节点。

2. `blocks/index/*` 是一个levelDB数据库，存储着目前已知块的元数据，这些元数据记录所有已知的块以及它们存储在磁盘上的位置。没有这些文件，查找一个块将是非常慢的。

3. `chainstate/*`是一个levelDB数据库，以紧凑的形式存储所有当前未花费的交易以及它们的元数据。这里的数据对于验证新传入的块和交易是必要的。在理论上，这些数据可以从块数据中重建，但是这需要很长时间。没有这些数据也可以对数据进行验证，但是需要现有块数据进行扫面，这无疑是非常慢的。

4. `blocks/rev*.dat` 中包含了“撤销”数据，可以将区块视为链的“补丁”（它们消耗一些未花费的输出并生成新的输出），那么这些撤销数据将是反向补丁。如果需要回滚链，这些数据将是必须的。
比特币程序从网络中接受数据后，会将数据以.dat的形式转储到磁盘上。

一个块文件大约为128MB。每个块文件会有一个对应的撤销文件，比如文件blocks/blk1234.dat和blocks/recv1234.dat对应。


## 2. 块结构

| 大小(字节) | 名称            | 数据类型 | 描述                                  |
| ---------- | --------------- | -------- | ------------------------------------- |
| 4          | magic_number    | uint32   | 总是 0xD9B4BEF9, 作为区块之间的分隔符 |
| 4          | block_size      | uint32   | 后面数据到块结束的字节数              |
| 80         | block_header    | char[]   | block heaer                           |
| varies     | transaction_cnt | uint     | 交易数量                              |
| varies     | transaction     | char[]   | 交易详情                              |

从原始数据中读取的流程大概如下

1. 读取4个字节，比对 magic_number
2. 一旦匹配，读取后4个字节，得到块的大小 m
3. 读取后面 m 个字节，得到区块的数据
4. 返回第一步，读取下一个区块

## 3. Block Header

block header固定 *80* 字节大小，结构如下

| 大小(字节) |        名称         | 数据类型 |               描述               |
| ---------- | ------------------- | -------- | -------------------------------- |
| 4          | version             | int32_t  | 版本号                           |
| 32         | previous_block_hash | char[32] | 前一个 block 的 hash 值          |
| 32         | merkle_root_hash    | char[32] | 区块内所有交易的 merkle_hash 值  |
| 4          | time                | uint32   | unix时间戳，矿工挖矿的时间       |
| 4          | nBits               | unit32   | 该块的标题hash必须小于的值。难度 |
| 4          | nonce               | unit32   | 随机值，用于产生满足难度的hash值 |

## 4. 交易

| 大小(字节) |     名称     | 数据类型 |     描述     |
| ---------- | ------------ | -------- | ------------ |
| 4          | version      | unit32   | 交易版本号   |
| varint     | tx_in_count  | uint     | 交易输入数量 |
| varies     | tx_in        | tx_in    | 交易输入     |
| varint     | tx_out_count | uint     | 交易输出数量 |
| varies     | txt_out      | tx_out   | 交易输出     |
| 4          | lock_time    | uint32   | 锁定时间     |

!!! note Varint
    交易中使用可变长度整数来表示下一条数据中的字节数。对于不同的数值，存储的空间不一样。

    对于0～252的值，只占用一个字节；对于其他小于0xffffffffffffffff的值，第一个字节将成为长度标识位。值和存储空间的关系如下表：

    |                   值                   | 存储空间 (字节) |       数据类型       |
    | -------------------------------------- | --------------- | -------------------- |
    | >=0 && <=252                           | 1               | uint8_t              |
    | >=253 && <= 0xffff                     | 3               | 后 2 个字节 uint16_t |
    | >=0x10000 && <= 0xffffffff             | 5               | 后 4 个字节 uint32_t |
    | >=0x100000000 && <= 0xffffffffffffffff | 9               | 后 8 个字节uint64_t  |

    !!! note 理解
        就是说

        1. 若 tx_in_count 的第 1 字节 <= 252，那么这个字节本身就是 `值`
        2. 若 tx_in_count 的第 1 字节 = 253，那么 `值` 存储在后面的 2 个字节里
        3. 若 tx_in_count 的第 1 字节 = 254，那么 `值` 存储在后面的 4 个字节里
        2. 若 tx_in_count 的第 1 字节 = 255，那么 `值` 存储在后面的 8 个字节里

## 5. 交易输入

每个非coinbase的交易输入都是之前某个交易的交易输出

交易输入的结构如下:

| 大小(字节) |         名称          | 数据类型 |     描述      |
| ---------- | --------------------- | -------- | ------------- |
| 32         | previous_output_hash  | outpoint | 前置交易hash  |
| 4          | previous_output_index | uint32   | 前置交易index |
| varint     | script_bytes          | uint     | 解锁脚本长度  |
| varies     | signature_script      | char[]   | 解锁脚本      |
| 4          | sequence              | uint32   | 序列号        |

## 6. 交易输出

| 大小(字节) |     名称      | 数据类型 |            描述            |
| ---------- | ------------- | -------- | -------------------------- |
| 8          | value         | int64    | 花费的数量，单位是聪       |
| 1+         | pk_sript_size | uint     | pubkey脚本中的字节数量     |
| varies     | pk_script     | char[]   | 花费这笔输出需要满足的条件 |
